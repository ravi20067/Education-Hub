{
    "courses": [
        {
            "id": "course1",
            "name": "Java",
            "chapters": [
                {
                    "id": "chapter1",
                    "name": "Introduction",
                    "miniChapters": [
                        {
                            "id": "mini1",
                            "name": "Introduction to Java",
                            "videos": ["https://www.youtube.com/embed/yRpLlJmRo2w"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture provides a comprehensive introduction to the Java programming language, covering its history, features, and fundamental concepts. Key points include:\n\n- **History of Java**: Originating in the mid-1990s, Java was developed by Sun Microsystems to create platform-independent software. Its 'write once, run anywhere' philosophy has contributed to its widespread adoption.\n\n- **Features of Java**: Java is known for its simplicity, object-oriented structure, platform independence, security features, and robustness. These characteristics make it a versatile choice for various applications, from mobile apps to large-scale enterprise systems.\n\n- **Java Development Kit (JDK)**: The JDK is essential for Java development, providing tools like the compiler and runtime environment necessary to build and run Java applications.\n\n- **Basic Syntax**: The lecture introduces Java's basic syntax, including data types, variables, operators, and control structures such as loops and conditional statements.\n\n- **Object-Oriented Programming (OOP) in Java**: Core OOP principles like classes, objects, inheritance, polymorphism, abstraction, and encapsulation are discussed, highlighting how Java implements these concepts to promote modular and reusable code.\n\n- **Java Standard Library**: An overview of Java's extensive standard library, which offers pre-built classes and methods for tasks ranging from data structures to networking and graphical user interface (GUI) development.\n\n- **Setting Up the Development Environment**: Guidance on installing the JDK and setting up an integrated development environment (IDE) to begin coding in Java.\n\n- **First Java Program**: A walkthrough of writing and executing a simple Java program, demonstrating the structure of a Java application and the process of compilation and execution.\n\n- **Memory Management**: Explanation of Java's automatic garbage collection mechanism, which helps in efficient memory management by reclaiming memory occupied by unused objects.\n\n- **Exception Handling**: Introduction to Java's approach to handling errors and exceptions, ensuring robust and error-resistant code.\n\nThis foundational topic equips learners with the essential knowledge required to embark on their Java programming journey, laying the groundwork for more advanced topics."
                        },                        
                        {
                            "id": "mini2",
                            "name": "Java Development Setup",
                            "videos": ["https://www.youtube.com/embed/LusTv0RlnSU"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture focuses on setting up the Java development environment, guiding viewers through the installation and configuration process to ensure a smooth start to their programming journey. Key points covered include:\n\n- **Downloading the JDK**: Instructions on obtaining the latest version of the Java Development Kit (JDK) from the official Oracle website, ensuring compatibility with the user's operating system.\n\n- **Installing the JDK**: Step-by-step guidance on installing the JDK, including setting up system environment variables such as `JAVA_HOME` and updating the system `PATH` to recognize Java commands globally.\n\n- **Verifying the Installation**: Methods to confirm successful installation by checking the Java version in the command line or terminal, ensuring that the system recognizes the Java compiler (`javac`) and runtime (`java`) commands.\n\n- **Choosing an IDE**: Overview of popular Integrated Development Environments (IDEs) like Eclipse, IntelliJ IDEA, and NetBeans, discussing their features to help users select the one that best fits their development needs.\n\n- **Installing and Configuring an IDE**: Detailed walkthrough of downloading, installing, and setting up a chosen IDE, including configuring the IDE to recognize the installed JDK and setting up necessary plugins or extensions for enhanced functionality.\n\n- **Creating a New Java Project**: Demonstration of initiating a new Java project within the IDE, setting up project directories, and understanding the project structure to organize code effectively.\n\n- **Writing and Running a Simple Java Program**: Hands-on example of writing a basic Java program, compiling, and executing it within the IDE to validate the development setup.\n\n- **Troubleshooting Common Issues**: Tips on resolving common setup problems, such as environment variable misconfigurations, IDE setup challenges, and compatibility issues, ensuring a smooth development experience.\n\n- **Introduction to Version Control**: Brief introduction to version control systems like Git, emphasizing the importance of source code management and collaboration in software development projects.\n\nThis comprehensive setup guide ensures that learners have a properly configured Java development environment, laying a solid foundation for effective coding and project management in their programming endeavors."
                        }                        
                    ]
                },
                {
                    "id": "chapter2",
                    "name": "Flow Control",
                    "miniChapters": [
                        {
                            "id": "mini1",
                            "name": "Conditional Statements",
                            "videos": ["https://www.youtube.com/embed/I5srDu75h_M"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture provides a detailed explanation of Java variables and data types, essential concepts for any Java programmer. Key topics covered include:\n\n- **Introduction to Variables**: Variables are used to store data in Java. The lecture explains how variables are declared, assigned values, and used in programs.\n\n- **Types of Variables**: Java has different types of variables, including local variables (declared inside a method), instance variables (declared inside a class but outside methods), and static variables (shared among all instances of a class).\n\n- **Primitive Data Types**: Java has eight primitive data types: `byte`, `short`, `int`, `long`, `float`, `double`, `char`, and `boolean`. Each data type has a specific memory size and purpose.\n\n- **Reference Data Types**: Objects, arrays, and classes are reference data types. The lecture explains how reference variables store memory addresses rather than actual values.\n\n- **Type Casting**: Java allows type conversion, including implicit (automatic) and explicit (manual) casting. For example, converting an `int` to a `double` happens automatically, but converting a `double` to an `int` requires explicit casting.\n\n- **Constants and Final Variables**: The `final` keyword is used to declare constants whose values cannot be changed once assigned.\n\n- **String Data Type**: Although `String` is a class in Java, it is used like a data type. The lecture covers how to declare, initialize, and manipulate strings using built-in methods.\n\n- **Memory Allocation for Variables**: Java's memory management for primitive and reference data types is explained, including stack and heap memory allocation.\n\n- **Scope and Lifetime of Variables**: The lecture discusses variable scope (local, instance, and global) and how long a variable exists in memory.\n\n- **Best Practices for Variable Naming and Usage**: Guidelines for writing clean and readable code, such as using meaningful variable names and following Java naming conventions.\n\nThis session provides a solid foundation in Java's variable and data type system, ensuring that beginners can effectively declare, use, and manipulate variables in their programs."
                        },
                        {
                            "id": "mini2",
                            "name": "Loops in Java",
                            "videos": ["https://www.youtube.com/embed/0r1SfRoLuzU"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture explains loops in Java, which are essential for executing repetitive tasks efficiently. Key topics covered include:\n\n- **Introduction to Loops**: Loops allow executing a block of code multiple times based on a condition, reducing redundancy in programming.\n\n- **Types of Loops in Java**: Java supports three main types of loops:\n  - **For Loop**: Used when the number of iterations is known beforehand.\n  - **While Loop**: Runs as long as a specified condition remains true.\n  - **Do-While Loop**: Similar to `while`, but guarantees at least one execution before checking the condition.\n\n- **For Loop Syntax and Example**: The lecture explains the syntax of a `for` loop with an example that prints numbers from 1 to 10.\n\n- **While Loop Explanation**: The `while` loop runs based on a condition. An example demonstrates its use in reading user input until a valid number is entered.\n\n- **Do-While Loop Usage**: Unlike `while`, the `do-while` loop executes once before checking the condition. A practical example is given for menu-based applications.\n\n- **Nested Loops**: The concept of using loops inside another loop is covered, with an example of printing a pattern using nested `for` loops.\n\n- **Loop Control Statements**:\n  - `break`: Exits the loop prematurely.\n  - `continue`: Skips the current iteration and moves to the next one.\n  - `return`: Exits from the entire method when used inside a loop.\n\n- **Best Practices in Using Loops**: Tips include avoiding infinite loops, using efficient conditions, and reducing unnecessary iterations for better performance.\n\nLoops are fundamental to Java programming, helping automate repetitive tasks efficiently. This session equips learners with a clear understanding of different looping mechanisms and their applications."
                        },
                        {
                            "id": "mini3",
                            "name": "9 loops questions",
                            "videos": ["https://www.youtube.com/embed/GjHNGM7KN3w"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture explains the usage of `if-else` and `switch-case` statements in Java, which allow decision-making based on conditions. Key topics covered include:\n\n- **Introduction to If-Else and Switch Case**: Conditional statements help in executing specific blocks of code based on conditions.\n\n- **If-Else Statement**:\n  - `if`: Executes a block of code only if the condition is true.\n  - `if-else`: Provides an alternative execution path if the condition is false.\n  - `if-else-if`: Used to check multiple conditions sequentially.\n  - Nested `if`: Allows placing one `if` inside another for complex decision-making.\n\n- **Switch Case Statement**:\n  - Used as an alternative to multiple `if-else` conditions.\n  - Works with `int`, `char`, `String`, and enums.\n  - Requires `case` labels, `break` statements to prevent fall-through, and an optional `default` case.\n  - Example: Implementing a simple menu-based program.\n\n- **Comparison and Logical Operators**:\n  - `==`, `!=`, `>`, `<`, `>=`, `<=` for comparisons.\n  - `&&`, `||`, `!` for logical operations within conditions.\n\n- **Examples and Use Cases**:\n  - Checking if a number is even or odd using `if-else`.\n  - Finding the largest of three numbers.\n  - Using `switch` for a calculator application.\n\n- **Common Mistakes and Best Practices**:\n  - Always using `{}` for multi-line `if` statements.\n  - Avoiding redundant conditions to optimize performance.\n  - Using `break` inside `switch` cases to prevent unintended execution.\n\nUnderstanding `if-else` and `switch-case` is crucial for writing decision-based programs in Java. This session provides practical insights into their implementation and best practices."
                        },
                        {
                            "id": "mini4",
                            "name": "Pattern Questions in Java",
                            "videos": ["https://www.youtube.com/embed/Dr4PpNa7AYo"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture focuses on solving pattern-based questions in Java using loops. Pattern printing is an important concept that helps in understanding nested loops and improving logical thinking. Key topics covered include:\n\n- **Introduction to Pattern Printing**:\n  - Pattern problems require printing structured shapes using loops.\n  - Helps in mastering nested loops and logic-building skills.\n\n- **Understanding Nested Loops**:\n  - Outer loops control the number of rows.\n  - Inner loops control elements within each row.\n  - Use of `System.out.print()` for inline printing and `System.out.println()` for new lines.\n\n- **Basic Patterns**:\n  - Printing a solid rectangle.\n  - Printing a hollow rectangle using conditions.\n  - Right-angled triangle patterns.\n\n- **Number and Alphabet Patterns**:\n  - Printing increasing and decreasing number patterns.\n  - Alphabet patterns using ASCII values.\n\n- **Advanced Patterns**:\n  - Pyramid patterns using spaces.\n  - Diamond patterns using nested loops.\n  - Inverted pyramid and hourglass patterns.\n\n- **Logical Approach to Pattern Solving**:\n  - Breaking problems into smaller parts.\n  - Identifying row and column relations.\n  - Using loops efficiently to avoid redundancy.\n\n- **Best Practices**:\n  - Using appropriate loop conditions to minimize execution time.\n  - Avoiding unnecessary print statements.\n  - Practicing common patterns to strengthen loop concepts.\n\nPattern-based problems are frequently asked in coding interviews and competitive programming. This session provides a step-by-step approach to solving different types of pattern questions using Java."
                        }                                                                    
                    ]
                },
                {
                    "id": "chapter3",
                    "name": "Funtions", 
                    "miniChapters": [
                        {
                            "id": "mini1",
                            "name": "Functions in Java: Definition and Usage",
                            "videos": ["https://www.youtube.com/embed/qcSz4ef9UHA"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture introduces functions in Java, explaining their importance, structure, and how they improve code reusability. The key topics covered include:\n\n- **What is a Function?**\n  - A function (also known as a method in Java) is a block of code designed to perform a specific task.\n  - Functions help in modular programming by breaking a large problem into smaller manageable parts.\n\n- **Why Use Functions?**\n  - Avoids code repetition by reusing code.\n  - Enhances readability and maintainability.\n  - Helps in debugging and testing by isolating functionalities.\n\n- **Types of Functions in Java**\n  - **Predefined Functions**: Functions provided by Java, like `Math.sqrt()`, `System.out.println()`, etc.\n  - **User-Defined Functions**: Functions created by the programmer to perform specific tasks.\n\n- **Function Structure in Java**\n  - Return type: Defines what the function returns (`void`, `int`, `String`, etc.).\n  - Function name: The unique identifier of the function.\n  - Parameters: Inputs passed to the function.\n  - Function body: Contains the logic of the function.\n  - Example:\n    ```java\n    public int add(int a, int b) {\n        return a + b;\n    }\n    ```\n\n- **Function Calling**\n  - Functions must be called in `main()` or other functions to execute.\n  - Example of calling a function:\n    ```java\n    int sum = add(5, 10);\n    System.out.println(sum); // Output: 15\n    ```\n\n- **Function Overloading**\n  - The ability to define multiple functions with the same name but different parameters.\n  - Example:\n    ```java\n    void display(int a) { System.out.println(a); }\n    void display(String s) { System.out.println(s); }\n    ```\n\n- **Return vs. Void Functions**\n  - `void` functions do not return values.\n  - Non-void functions return a specific value using `return`.\n\n- **Scope of Variables in Functions**\n  - Local variables: Exist only within a function.\n  - Global variables: Declared outside functions and accessible throughout the program.\n\nFunctions are a crucial part of Java programming, allowing better structure, reusability, and maintainability of code."
                        },
                        {
                            "id": "mini2",
                            "name": "Call by Value and Call by Reference in Java",
                            "videos": ["https://www.youtube.com/embed/pFPZ83mgH00"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture explains the concept of passing parameters in Java using Call by Value and Call by Reference. It covers how Java handles data transfer between functions and the impact on variables.\n\n- **What is Call by Value?**\n  - In Java, all primitive data types (int, float, char, etc.) are passed by value.\n  - A copy of the variable is created and sent to the function.\n  - Any changes made inside the function do not affect the original variable.\n  - Example:\n    ```java\n    void change(int x) {\n        x = 10;\n    }\n    int num = 5;\n    change(num);\n    System.out.println(num); // Output: 5 (unchanged)\n    ```\n\n- **What is Call by Reference?**\n  - Java does not support Call by Reference directly but uses object references.\n  - When passing objects (like arrays), changes made inside the function affect the original object.\n  - Example:\n    ```java\n    void modifyArray(int[] arr) {\n        arr[0] = 100;\n    }\n    int[] nums = {1, 2, 3};\n    modifyArray(nums);\n    System.out.println(nums[0]); // Output: 100 (modified)\n    ```\n\n- **Key Differences Between Call by Value and Call by Reference:**\n  - **Call by Value:** Works with primitive types, passes a copy, and does not modify the original variable.\n  - **Call by Reference:** Works with objects, passes the reference, and modifies the actual object.\n\n- **Why Java Uses Call by Value for Objects?**\n  - Java passes object references by value, meaning the reference itself is copied, not the object.\n  - Modifications affect the object but reassigning the reference does not affect the original.\n\nUnderstanding these concepts is crucial for handling functions, memory, and data structures in Java efficiently."
                        }                        
                    ]
                },
                {
                    "id": "chapter4",
                    "name": "Complexity Analysis",
                    "miniChapters": [
                        {
                            "id": "mini1",
                            "name": "Time and Space Complexity in Java",
                            "videos": ["https://www.youtube.com/embed/bQssdSrSGNE"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture explains the fundamental concepts of time and space complexity in Java, which are essential for analyzing the efficiency of algorithms.\n\n- **What is Time Complexity?**\n  - Measures how the execution time of an algorithm grows as the input size increases.\n  - Expressed using Big-O notation (O(n), O(log n), O(n²), etc.).\n  - Example:\n    ```java\n    // O(n) Complexity\n    void printNumbers(int n) {\n        for (int i = 0; i < n; i++) {\n            System.out.println(i);\n        }\n    }\n    ```\n\n- **Common Time Complexities:**\n  - **O(1) - Constant Time:** Execution does not depend on input size.\n  - **O(log n) - Logarithmic Time:** Input size reduces exponentially at each step.\n  - **O(n) - Linear Time:** Execution time increases proportionally with input size.\n  - **O(n²) - Quadratic Time:** Used in nested loops, grows rapidly.\n  - **O(2^n) - Exponential Time:** Extremely slow, common in recursion-based solutions.\n\n- **What is Space Complexity?**\n  - Measures how much memory an algorithm uses as the input size increases.\n  - Includes memory used for variables, function calls, and auxiliary structures.\n  - Example:\n    ```java\n    // O(n) Space Complexity\n    int[] createArray(int n) {\n        return new int[n];\n    }\n    ```\n\n- **Trade-offs Between Time and Space Complexity:**\n  - Some algorithms use extra memory to optimize execution speed (e.g., dynamic programming).\n  - Choosing the right algorithm depends on the constraints and requirements of the problem.\n\nUnderstanding complexity helps in selecting the best algorithm for efficient problem-solving in Java programming."
                        }
                    ]                        
                },
                {
                    "id": "chapter5",
                    "name": "Arrays and Strings",
                    "miniChapters": [
                        {
                            "id": "mini1",
                            "name": "Introduction to Arrays in Java",
                            "videos": ["https://www.youtube.com/embed/NTHVTY6w2Co"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture introduces arrays in Java, explaining their importance, types, and usage in programming.\n\n- **What is an Array?**\n  - A collection of elements of the same data type stored in contiguous memory locations.\n  - Allows easy data access and manipulation using index-based operations.\n\n- **Why Use Arrays?**\n  - Efficiently store multiple values of the same type under one variable.\n  - Reduces the need for multiple individual variables.\n  - Supports fast access using indexing.\n\n- **Declaring and Initializing Arrays:**\n  - **Declaration:** `dataType[] arrayName;` or `dataType arrayName[];`\n  - **Initialization:**\n    ```java\n    int[] numbers = new int[5]; // Creates an array of size 5\n    int[] values = {10, 20, 30, 40, 50}; // Direct initialization\n    ```\n\n- **Accessing Elements in an Array:**\n  - Elements are accessed using zero-based indexing.\n  - Example:\n    ```java\n    int[] arr = {5, 10, 15};\n    System.out.println(arr[0]); // Output: 5\n    ```\n\n- **Types of Arrays in Java:**\n  - **One-dimensional arrays:** Store a single list of elements.\n  - **Multi-dimensional arrays:** Store multiple lists (like matrices).\n    ```java\n    int[][] matrix = {{1, 2}, {3, 4}}; // 2D array\n    ```\n\n- **Advantages of Arrays:**\n  - Faster access time compared to linked lists.\n  - Easy iteration using loops.\n  - Supports bulk storage of data.\n\n- **Limitations of Arrays:**\n  - Fixed size (cannot dynamically grow or shrink).\n  - Insertion and deletion operations are costly.\n\nUnderstanding arrays is fundamental for data storage and algorithm development in Java programming."
                        },
                        {
                            "id": "mini2",
                            "name": "Introduction to 2D Arrays in Java",
                            "videos": ["https://www.youtube.com/embed/18Zt5I4S45o"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture introduces **2D Arrays in Java**, explaining their structure, initialization, traversal, and practical applications.\n\n- **What is a 2D Array?**\n  - A two-dimensional array is an array of arrays, structured like a matrix or table.\n  - It stores elements in **rows and columns**, making it useful for handling grid-like data structures.\n\n- **Declaration and Initialization:**\n  - **Syntax:** `dataType[][] arrayName = new dataType[rows][columns];`\n  - **Example:**\n    ```java\n    int[][] matrix = new int[3][3]; // Creates a 3x3 matrix\n    ```\n  - **Direct Initialization:**\n    ```java\n    int[][] matrix = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n    ```\n\n- **Accessing Elements in a 2D Array:**\n  - Elements are accessed using two indices: `array[row][column]`\n  - Example:\n    ```java\n    System.out.println(matrix[1][2]); // Accesses row 1, column 2 (zero-based indexing)\n    ```\n\n- **Traversing a 2D Array Using Loops:**\n  - Using **nested loops** to iterate through all elements:\n    ```java\n    for (int i = 0; i < matrix.length; i++) { // Row loop\n        for (int j = 0; j < matrix[i].length; j++) { // Column loop\n            System.out.print(matrix[i][j] + \" \");\n        }\n        System.out.println();\n    }\n    ```\n\n- **Common Applications of 2D Arrays:**\n  - Storing **game boards** (e.g., Tic-Tac-Toe, Chess, Sudoku).\n  - Representing **graphs and adjacency matrices**.\n  - Managing **image pixels in image processing**.\n  - Storing **tabular data like spreadsheets**.\n\n- **Advantages of 2D Arrays:**\n  - Efficiently store and manage tabular data.\n  - Supports structured data organization.\n\n- **Limitations of 2D Arrays:**\n  - Fixed size (cannot dynamically grow like ArrayLists).\n  - Access time can increase with larger data sets.\n\nUnderstanding **2D arrays** is essential for handling grid-based problems in Java programming."
                        },
                        {
                            "id": "mini3",
                            "name": "Introduction to Strings in Java",
                            "videos": ["https://www.youtube.com/embed/vCRD36bG8xQ"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture covers **Strings in Java**, explaining their properties, creation methods, operations, and real-world applications.\n\n- **What is a String?**\n  - A sequence of characters enclosed in double quotes (`\" \"`).\n  - Strings in Java are **immutable**, meaning their values cannot be changed once assigned.\n\n- **Creating Strings in Java:**\n  - Using **String literals**:\n    ```java\n    String str1 = \"Hello World\";\n    ```\n  - Using **String objects**:\n    ```java\n    String str2 = new String(\"Java Programming\");\n    ```\n\n- **Common String Methods:**\n  - **`length()`** – Returns the length of the string:\n    ```java\n    System.out.println(str1.length()); // Output: 11\n    ```\n  - **`charAt(index)`** – Returns the character at a given index:\n    ```java\n    System.out.println(str1.charAt(0)); // Output: H\n    ```\n  - **`substring(start, end)`** – Extracts part of the string:\n    ```java\n    System.out.println(str1.substring(0, 5)); // Output: Hello\n    ```\n  - **`toUpperCase()` / `toLowerCase()`** – Converts string case:\n    ```java\n    System.out.println(str1.toUpperCase()); // Output: HELLO WORLD\n    ```\n  - **`concat(String s)`** – Joins two strings:\n    ```java\n    System.out.println(str1.concat(\" Java\")); // Output: Hello World Java\n    ```\n  - **`equals(String s)`** – Checks if two strings are equal:\n    ```java\n    System.out.println(str1.equals(\"Hello World\")); // Output: true\n    ```\n  - **`replace(oldChar, newChar)`** – Replaces characters in a string:\n    ```java\n    System.out.println(str1.replace('o', 'a')); // Output: Hella Warld\n    ```\n\n- **String Comparison in Java:**\n  - Using **`equals()`** (checks value equality)\n  - Using **`==` operator** (checks memory reference equality)\n  - Using **`compareTo()`** for lexicographical comparison\n\n- **StringBuilder vs. StringBuffer:**\n  - `StringBuilder` is **faster** but **not thread-safe**.\n  - `StringBuffer` is **thread-safe** but **slower**.\n\n- **Applications of Strings in Java:**\n  - Used in **text processing and manipulation**.\n  - Essential for **file handling, web development, and database operations**.\n  - Used in **string pattern matching (e.g., Regular Expressions)**.\n\nUnderstanding **Strings** is crucial for text manipulation and handling in Java programming."
                        },
                        {
                            "id": "mini4",
                            "name": "Understanding StringBuilder in Java",
                            "videos": ["https://www.youtube.com/embed/ZLDwskEhIFg"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture covers **StringBuilder in Java**, explaining its functionality, advantages over regular Strings, and its common operations.\n\n- **What is StringBuilder?**\n  - A **mutable sequence of characters** that allows efficient string manipulation.\n  - Unlike `String`, it does not create new objects for every modification.\n\n- **Why Use StringBuilder?**\n  - Faster than `String` when performing multiple modifications.\n  - More memory-efficient since it modifies strings in place.\n\n- **Creating a StringBuilder Object:**\n  ```java\n  StringBuilder sb = new StringBuilder(\"Hello\");\n  ```\n\n- **Common StringBuilder Methods:**\n  - **`append(String s)`** – Adds a string at the end:\n    ```java\n    sb.append(\" World\");\n    System.out.println(sb); // Output: Hello World\n    ```\n  - **`insert(int offset, String s)`** – Inserts a string at a specified position:\n    ```java\n    sb.insert(5, \" Java\");\n    System.out.println(sb); // Output: Hello Java World\n    ```\n  - **`replace(int start, int end, String s)`** – Replaces a part of the string:\n    ```java\n    sb.replace(6, 10, \"C++\");\n    System.out.println(sb); // Output: Hello C++ World\n    ```\n  - **`delete(int start, int end)`** – Removes a part of the string:\n    ```java\n    sb.delete(5, 10);\n    System.out.println(sb); // Output: Hello World\n    ```\n  - **`reverse()`** – Reverses the string:\n    ```java\n    sb.reverse();\n    System.out.println(sb); // Output: dlroW olleH\n    ```\n  - **`length()` and `capacity()`** – Returns string length and buffer capacity:\n    ```java\n    System.out.println(sb.length());   // Output: 11\n    System.out.println(sb.capacity()); // Default is 16 + initial string length\n    ```\n\n- **Difference Between String, StringBuffer, and StringBuilder:**\n  | Feature       | String       | StringBuffer    | StringBuilder   |\n  |--------------|-------------|----------------|----------------|\n  | Mutability   | Immutable   | Mutable        | Mutable        |\n  | Thread-safe  | Yes         | Yes            | No             |\n  | Performance  | Slow        | Medium         | Fast           |\n\n- **Applications of StringBuilder:**\n  - Used for **dynamic string manipulation**.\n  - Helpful in **creating large strings efficiently**.\n  - Common in **competitive programming and real-time applications**.\n\nUsing **StringBuilder** improves performance and efficiency in Java programming."
                        }                                                            
                    ]
                },
                {
                    "id": "chapter6",
                    "name": "Binary system",
                    "miniChapters":[
                        {
                            "id": "mini1",
                            "name": "Operators and Binary System in Java",
                            "videos": ["https://www.youtube.com/embed/Oud4alVQU4s"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture covers **Operators and the Binary System in Java**, including arithmetic, logical, bitwise operations, and binary number representation.\n\n- **Binary Number System Overview:**\n  - Computers store and process data using the **binary system (0s and 1s).**\n  - Each digit in binary represents a power of **2**.\n  - Example: `1011` in binary equals **(1×8 + 0×4 + 1×2 + 1×1) = 11** in decimal.\n\n- **Types of Operators in Java:**\n  1. **Arithmetic Operators** – `+`, `-`, `*`, `/`, `%`\n  2. **Relational (Comparison) Operators** – `==`, `!=`, `>`, `<`, `>=`, `<=`\n  3. **Logical Operators** – `&&` (AND), `||` (OR), `!` (NOT)\n  4. **Bitwise Operators** – `&`, `|`, `^`, `~`, `<<`, `>>`\n  5. **Assignment Operators** – `=`, `+=`, `-=`, `*=`, `/=`, `%=`\n  6. **Increment & Decrement Operators** – `++`, `--`\n  7. **Ternary Operator** – `condition ? expr1 : expr2`\n\n- **Bitwise Operations in Java:**\n  - `&` (AND): `5 & 3` → `0101 & 0011 = 0001 (1)`\n  - `|` (OR): `5 | 3` → `0101 | 0011 = 0111 (7)`\n  - `^` (XOR): `5 ^ 3` → `0101 ^ 0011 = 0110 (6)`\n  - `~` (NOT): `~5` → `~(0101) = 1010` (2's complement)\n  - `<<` (Left Shift): `5 << 1` → `1010 (10)`\n  - `>>` (Right Shift): `5 >> 1` → `0010 (2)`\n\n- **Practical Applications:**\n  - Used in **low-level programming**, **encryption**, and **game development**.\n  - Essential for **memory-efficient calculations** and **performance optimization** in Java."
                        },
                        {
                            "id": "mini2",
                            "name": "Bit Manipulation in Java",
                            "videos": ["https://www.youtube.com/embed/OSoO8eCEEC8"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture explores **Bit Manipulation in Java**, a powerful technique used in performance optimization, encryption, and system-level programming.\n\n- **What is Bit Manipulation?**\n  - Directly modifying bits of an integer for efficiency.\n  - Used in **fast arithmetic operations**, **data compression**, and **networking**.\n\n- **Common Bitwise Operators:**\n  - **AND (`&`)** – Sets bit to `1` if both bits are `1`.\n  - **OR (`|`)** – Sets bit to `1` if at least one bit is `1`.\n  - **XOR (`^`)** – Sets bit to `1` if bits are different.\n  - **NOT (`~`)** – Flips all bits.\n  - **Left Shift (`<<`)** – Multiplies by `2^n`.\n  - **Right Shift (`>>`)** – Divides by `2^n`.\n\n- **Bit Manipulation Tricks in Java:**\n  - **Check if a number is even or odd:**\n    ```java\n    boolean isEven = (num & 1) == 0;\n    ```\n  - **Get the `i`th bit of a number:**\n    ```java\n    int bit = (num >> i) & 1;\n    ```\n  - **Set the `i`th bit to `1`:**\n    ```java\n    num = num | (1 << i);\n    ```\n  - **Clear the `i`th bit:**\n    ```java\n    num = num & ~(1 << i);\n    ```\n  - **Toggle the `i`th bit:**\n    ```java\n    num = num ^ (1 << i);\n    ```\n\n- **Bit Manipulation Applications:**\n  - Used in **competitive programming** to solve problems efficiently.\n  - Essential in **cryptography** for secure data transmission.\n  - Helps in **data compression algorithms** like Huffman coding.\n\nUnderstanding **bitwise operations** is crucial for performance-optimized Java programming."
                        }                                              
                    ]
                },
                {
                    "id": "chapter7",
                    "name": "Recursion",
                    "miniChapters":[
                        {
                            "id": "mini1",
                            "name": "Recursion Part 1 - Introduction",
                            "videos": ["https://www.youtube.com/embed/5Boqfjissv0"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture introduces **Recursion**, a fundamental programming concept where a function calls itself to break down complex problems into smaller subproblems.\n\n- **What is Recursion?**\n  - A function that calls itself within its definition.\n  - Used in **divide-and-conquer algorithms, tree traversal, and problem-solving**.\n\n- **Components of Recursion:**\n  - **Base Case:** The condition where recursion stops.\n  - **Recursive Case:** The function calls itself with modified arguments.\n\n- **Example: Factorial Calculation Using Recursion**\n  ```java\n  int factorial(int n) {\n      if (n == 0) return 1; // Base Case\n      return n * factorial(n - 1); // Recursive Case\n  }\n  ```\n\n- **Key Properties of Recursion:**\n  - Every recursion problem must have a **base case** to avoid infinite loops.\n  - Recursive calls use **stack memory**, which can lead to **stack overflow** if the depth is too large.\n\n- **Advantages of Recursion:**\n  - Makes code **simpler and more readable** for problems like tree traversals.\n  - Reduces the need for **explicit loops** in certain cases.\n\n- **Disadvantages of Recursion:**\n  - Can be **inefficient** without optimization (e.g., redundant calculations in Fibonacci series).\n  - **Consumes more memory** due to function call stack overhead.\n\nUnderstanding recursion is essential for solving **complex computational problems efficiently**."
                        },
                        {
                            "id": "mini2",
                            "name": "Recursion Part 2 - Problem Solving",
                            "videos": ["https://www.youtube.com/embed/u-HgzgYe8KA"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture focuses on **Recursion Problem Solving**, demonstrating how recursion can be applied to solve computational problems efficiently.\n\n- **Recap of Recursion Concepts:**\n  - **Base Case & Recursive Case**\n  - **Stack Memory Usage**\n  - **Importance of Termination Conditions**\n\n- **Problems Discussed:**\n  1. **Factorial Calculation:** Using recursion to compute `n!`.\n  2. **Power Function (`a^b`) Using Recursion:**\n     ```java\n     int power(int a, int b) {\n         if (b == 0) return 1; // Base Case\n         return a * power(a, b - 1); // Recursive Case\n     }\n     ```\n  3. **Fibonacci Series:** Recursively calculating Fibonacci numbers.\n  4. **Sum of First `n` Natural Numbers:**\n     ```java\n     int sum(int n) {\n         if (n == 0) return 0; // Base Case\n         return n + sum(n - 1); // Recursive Case\n     }\n     ```\n\n- **Key Takeaways:**\n  - **Identifying Base and Recursive Cases** is crucial.\n  - Recursion is useful for **breaking down complex problems** into smaller subproblems.\n  - **Avoid unnecessary recursive calls** to prevent inefficiency.\n\nUnderstanding recursion through problem-solving enhances **logical thinking and algorithmic skills**."
                        },
                        {
                            "id": "mini3",
                            "name": "Recursion - Advanced Level Questions",
                            "videos": ["https://www.youtube.com/embed/xZykmhcWGuY"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture explores **Advanced Level Recursion Problems**, tackling more complex recursive patterns and optimizations.\n\n- **Concepts Covered:**\n  - Recursion **Depth and Stack Usage**\n  - **Optimizing Recursive Calls** using **Memoization**\n  - **Multiple Recursive Calls** in a single function\n\n- **Problems Discussed:**\n  1. **Tower of Hanoi:** Moving `n` disks from one peg to another following constraints.\n  2. **Subsets and Subsequences Generation:** Using recursion to generate all possible subsets of an array or string.\n  3. **Permutations of a String:** Recursively generating all possible arrangements of characters.\n  4. **N-Queens Problem:** Placing queens on a chessboard such that no two queens attack each other.\n\n- **Code Example (Subsets Generation in Java):**\n  ```java\n  void generateSubsets(String str, String current, int index) {\n      if (index == str.length()) {\n          System.out.println(current);\n          return;\n      }\n      generateSubsets(str, current + str.charAt(index), index + 1); // Include\n      generateSubsets(str, current, index + 1); // Exclude\n  }\n  ```\n\n- **Key Takeaways:**\n  - Advanced recursion problems often involve **backtracking** and **multiple recursive calls**.\n  - **Recursive Tree Visualization** helps in debugging and understanding execution.\n  - Optimizing recursion is necessary to prevent **stack overflow and inefficiencies**.\n\nMastering these advanced problems improves **algorithmic thinking and problem-solving skills** for competitive programming."
                        },
                        {
                            "id": "mini4",
                            "name": "Backtracking in Java",
                            "videos": ["https://www.youtube.com/embed/bRs6E_SL2Tk"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture introduces **Backtracking in Java**, an algorithmic technique used to solve problems by **exploring all possibilities recursively** and **pruning unnecessary paths**.\n\n- **What is Backtracking?**\n  - A refined brute-force approach that tries **all possible solutions** but backtracks when it finds a constraint violation.\n  - Used in problems where the solution is built **step-by-step** and invalid solutions are abandoned early.\n\n- **Key Concepts Covered:**\n  1. **Decision Trees and State Space Search**\n  2. **Pruning to Reduce Time Complexity**\n  3. **Recursive Backtracking Implementation**\n\n- **Problems Discussed:**\n  - **N-Queens Problem:** Placing `n` queens on an `n x n` chessboard.\n  - **Sudoku Solver:** Using recursion and backtracking to fill a Sudoku grid.\n  - **Rat in a Maze:** Finding paths in a maze using backtracking.\n  - **Word Search in a Grid:** Checking if a word exists by traversing grid cells recursively.\n\n- **Code Example (N-Queens Solution in Java):**\n  ```java\n  void solveNQueens(int board[][], int row) {\n      if (row == board.length) {\n          printBoard(board);\n          return;\n      }\n      for (int col = 0; col < board.length; col++) {\n          if (isSafe(board, row, col)) {\n              board[row][col] = 1;\n              solveNQueens(board, row + 1);\n              board[row][col] = 0; // Backtrack\n          }\n      }\n  }\n  ```\n\n- **Key Takeaways:**\n  - **Backtracking is useful in solving constraint satisfaction problems.**\n  - Helps in **reducing unnecessary computations** using pruning.\n  - **Understanding recursion** is key to mastering backtracking.\n\nThis concept is crucial for **competitive programming, AI algorithms, and game development.**"
                        },
                        {
                            "id": "mini5",
                            "name": "Sudoku Solver using Backtracking in Java",
                            "videos": ["https://www.youtube.com/embed/tRj4VlVTat8"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture covers **solving a Sudoku puzzle using Backtracking in Java**, an important application of recursion.\n\n- **What is Sudoku?**\n  - A **9x9 grid** puzzle where each row, column, and **3x3 subgrid** must contain numbers `1-9` **without repetition**.\n  - Solved by placing numbers while ensuring constraints are met.\n\n- **How Backtracking Works in Sudoku?**\n  1. Find an **empty cell**.\n  2. Try placing a number (`1-9`).\n  3. Check if it **violates any constraints**.\n  4. If valid, **recur** to the next cell.\n  5. If no solution is found, **backtrack** (remove the last placed number and try another).\n\n- **Java Code Implementation:**\n  ```java\n  boolean solveSudoku(int[][] board) {\n      for (int row = 0; row < 9; row++) {\n          for (int col = 0; col < 9; col++) {\n              if (board[row][col] == 0) {\n                  for (int num = 1; num <= 9; num++) {\n                      if (isSafe(board, row, col, num)) {\n                          board[row][col] = num;\n                          if (solveSudoku(board)) return true;\n                          board[row][col] = 0; // Backtrack\n                      }\n                  }\n                  return false;\n              }\n          }\n      }\n      return true;\n  }\n  ```\n\n- **Key Takeaways:**\n  - **Backtracking efficiently solves Sudoku** by eliminating invalid placements early.\n  - **Understanding recursion** is essential for implementing this algorithm.\n  - **Optimizations like constraint propagation** can further enhance efficiency.\n\nThis problem is crucial for **interviews, competitive programming, and AI-based puzzle solvers.**"
                        }                                                                                     
                    ]
                },
                {
                    "id": "chapter8",
                    "name": "Sorting Algorithms",
                    "miniChapters":[
                        {
                            "id": "mini1",
                            "name": "Merge Sort Algorithm in Java",
                            "videos": ["https://www.youtube.com/embed/unxAnJBy12Q"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture covers **Merge Sort in Java**, a popular **Divide and Conquer** sorting algorithm with `O(n log n)` complexity.\n\n- **What is Merge Sort?**\n  - A **stable, efficient sorting algorithm** that recursively divides an array into halves, sorts each half, and merges them.\n  - **Time Complexity:** `O(n log n)` in all cases (best, worst, and average).\n  - **Space Complexity:** `O(n)` due to auxiliary space used in merging.\n\n- **Merge Sort Steps:**\n  1. **Divide:** Split the array into two halves until each sub-array has **one element**.\n  2. **Conquer:** Recursively **sort** the two halves.\n  3. **Merge:** Combine two sorted halves into a single sorted array.\n\n- **Java Implementation:**\n  ```java\n  void mergeSort(int arr[], int left, int right) {\n      if (left < right) {\n          int mid = left + (right - left) / 2;\n          mergeSort(arr, left, mid);\n          mergeSort(arr, mid + 1, right);\n          merge(arr, left, mid, right);\n      }\n  }\n\n  void merge(int arr[], int left, int mid, int right) {\n      int n1 = mid - left + 1;\n      int n2 = right - mid;\n      int L[] = new int[n1], R[] = new int[n2];\n      for (int i = 0; i < n1; i++) L[i] = arr[left + i];\n      for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];\n      int i = 0, j = 0, k = left;\n      while (i < n1 && j < n2) arr[k++] = (L[i] <= R[j]) ? L[i++] : R[j++];\n      while (i < n1) arr[k++] = L[i++];\n      while (j < n2) arr[k++] = R[j++];\n  }\n  ```\n\n- **Why Use Merge Sort?**\n  - **Guaranteed `O(n log n)` performance** (better than `O(n²)` algorithms like Bubble Sort and Insertion Sort).\n  - **Stable Sort:** Maintains the relative order of equal elements.\n  - **Used in external sorting (large datasets that don't fit in memory).**\n\nMerge Sort is **crucial for coding interviews, data structures, and algorithm optimization.**"
                        },
                        {
                            "id": "mini2",
                            "name": "Quick Sort Algorithm in Java",
                            "videos": ["https://www.youtube.com/embed/QXum8HQd_l4"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture covers **Quick Sort in Java**, a highly efficient **Divide and Conquer** sorting algorithm with an average time complexity of `O(n log n)`.\n\n- **What is Quick Sort?**\n  - Quick Sort selects a **pivot element** and partitions the array around it.\n  - **Best & Average Case Complexity:** `O(n log n)`\n  - **Worst Case Complexity:** `O(n²)` (when the pivot selection is poor)\n  - **In-place sorting** (does not require extra space like Merge Sort)\n\n- **Quick Sort Steps:**\n  1. **Choose a Pivot** (typically last element, first element, or median)\n  2. **Partition the array** into two parts:\n     - Left side: Elements **less than pivot**\n     - Right side: Elements **greater than pivot**\n  3. **Recursively apply Quick Sort** to the left and right parts.\n\n- **Java Implementation:**\n  ```java\n  void quickSort(int arr[], int low, int high) {\n      if (low < high) {\n          int pi = partition(arr, low, high);\n          quickSort(arr, low, pi - 1);\n          quickSort(arr, pi + 1, high);\n      }\n  }\n\n  int partition(int arr[], int low, int high) {\n      int pivot = arr[high];\n      int i = (low - 1);\n      for (int j = low; j < high; j++) {\n          if (arr[j] < pivot) {\n              i++;\n              int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;\n          }\n      }\n      int temp = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = temp;\n      return i + 1;\n  }\n  ```\n\n- **Why Use Quick Sort?**\n  - **Faster than Merge Sort for in-memory sorting** due to lower constant factors.\n  - **Efficient for large datasets** with good pivot selection.\n  - **Used in libraries like Java's `Arrays.sort()` (Dual-Pivot QuickSort)**.\n\nQuick Sort is **one of the most widely used sorting algorithms** due to its efficiency and in-place nature."
                        }                        
                    ]
                },
                {
                    "id": "chapter9",
                    "name":"OOPS",
                    "miniChapters":[
                        {
                            "id": "mini1",
                            "name": "Introduction to Object-Oriented Programming (OOPs) in Java",
                            "videos": ["https://www.youtube.com/embed/bSrm9RXwBaI"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture introduces **Object-Oriented Programming (OOPs) in Java**, a programming paradigm based on objects and classes, which makes code reusable and modular.\n\n- **What is OOP?**\n  - **Object-Oriented Programming** is a method of structuring programs using objects.\n  - It enhances **modularity, code reuse, and security**.\n\n- **Key Principles of OOP:**\n  1. **Encapsulation** - Bundling data and methods inside a class.\n  2. **Abstraction** - Hiding complex details and showing only necessary features.\n  3. **Inheritance** - A class acquiring properties of another class.\n  4. **Polymorphism** - Ability to take multiple forms (Method Overloading & Overriding).\n\n- **Why Use OOP?**\n  - **Improves Code Reusability** with Inheritance.\n  - **Enhances Security** using Encapsulation.\n  - **Simplifies Debugging & Maintenance** with modular structure.\n  - **Used in Real-World Applications** (e.g., Android Development, Game Development, Banking Systems).\n\n- **Basic Java OOP Example:**\n  ```java\n  class Animal {\n      String name;\n      void makeSound() {\n          System.out.println(\"Animal makes a sound\");\n      }\n  }\n  class Dog extends Animal {\n      void makeSound() {\n          System.out.println(\"Dog barks\");\n      }\n  }\n  public class Main {\n      public static void main(String args[]) {\n          Dog d = new Dog();\n          d.makeSound();  // Output: Dog barks\n      }\n  }\n  ```\n\nUnderstanding **OOPs concepts** is essential for **Java programming**, as most modern applications use OOP principles for better **scalability and maintainability**."
                        },
                        {
                            "id": "mini2",
                            "name": "ArrayList in Java",
                            "videos": ["https://www.youtube.com/embed/liFyhzZl9uw"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture covers **ArrayList in Java**, a dynamic array implementation in the Java Collection Framework.\n\n- **What is an ArrayList?**\n  - `ArrayList` is a **resizable array** in Java, part of `java.util` package.\n  - Unlike arrays, it can grow and shrink dynamically.\n\n- **Creating an ArrayList:**\n  ```java\n  import java.util.ArrayList;\n  public class Main {\n      public static void main(String[] args) {\n          ArrayList<String> list = new ArrayList<>();\n          list.add(\"Apple\");\n          list.add(\"Banana\");\n          list.add(\"Cherry\");\n          System.out.println(list); // Output: [Apple, Banana, Cherry]\n      }\n  }\n  ```\n\n- **ArrayList Methods:**\n  - `add(element)`, `add(index, element)`: Adds elements to the list.\n  - `get(index)`: Retrieves an element.\n  - `set(index, element)`: Updates an element.\n  - `remove(index)`: Removes an element.\n  - `size()`: Returns the size of the list.\n  - `contains(element)`: Checks if an element exists.\n\n- **Iterating Through an ArrayList:**\n  ```java\n  for (String fruit : list) {\n      System.out.println(fruit);\n  }\n  ```\n\n- **Advantages of ArrayList over Arrays:**\n  - **Dynamic Sizing** - No need to define size upfront.\n  - **Built-in Methods** - Simplifies data manipulation.\n  - **Faster Insertion/Deletion** compared to arrays.\n\n- **Real-World Applications:**\n  - Used in **dynamic data storage**, **shopping cart systems**, and **database management**.\n\nMastering `ArrayList` is essential for **Java programming**, especially in **data structures and algorithm implementation**."
                        },
                        {
                            "id": "mini3",
                            "name": "Java Collection Framework",
                            "videos": ["https://www.youtube.com/embed/VphowcSkBX4"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture covers the **Java Collection Framework (JCF)**, which provides a standardized way to handle and manipulate groups of objects efficiently.\n\n- **What is the Java Collection Framework?**\n  - A set of classes and interfaces in `java.util` that provides data structures like **List, Set, Queue, and Map**.\n  - Improves **performance, scalability, and reusability**.\n\n- **Core Interfaces in JCF:**\n  1. **List Interface** - Allows duplicates and maintains insertion order (e.g., `ArrayList`, `LinkedList`).\n  2. **Set Interface** - No duplicate elements allowed (e.g., `HashSet`, `TreeSet`).\n  3. **Queue Interface** - Follows **FIFO (First In, First Out)** (e.g., `PriorityQueue`, `Deque`).\n  4. **Map Interface** - Stores key-value pairs (e.g., `HashMap`, `TreeMap`).\n\n- **Common Collection Classes:**\n  - `ArrayList` - Dynamic resizable array.\n  - `LinkedList` - Doubly linked list implementation.\n  - `HashSet` - Unordered set without duplicates.\n  - `TreeSet` - Sorted set implementation.\n  - `HashMap` - Stores data in key-value pairs.\n  - `PriorityQueue` - Implements a **min/max heap**.\n\n- **Example: Using an ArrayList in JCF:**\n  ```java\n  import java.util.ArrayList;\n  public class Main {\n      public static void main(String[] args) {\n          ArrayList<String> names = new ArrayList<>();\n          names.add(\"Alice\");\n          names.add(\"Bob\");\n          System.out.println(names); // Output: [Alice, Bob]\n      }\n  }\n  ```\n\n- **Why Use the Java Collection Framework?**\n  - Provides **efficient and reusable** data structures.\n  - Supports **sorting, searching, and data manipulation**.\n  - Reduces development effort with built-in methods.\n\n- **Real-World Applications:**\n  - Used in **database management**, **search engines**, and **game development**.\n\nMastering the **Java Collection Framework** is essential for **efficient data handling and competitive programming**."
                        },   
                        {
                            "id": "mini4",
                            "name": "Introduction to Linked List in Java",
                            "videos": ["https://www.youtube.com/embed/oAja8-Ulz6o"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture introduces **Linked Lists in Java**, covering their structure, advantages, and basic operations.\n\n- **What is a Linked List?**\n  - A **dynamic data structure** where elements (nodes) are linked using **pointers**.\n  - Unlike arrays, **linked lists do not require contiguous memory allocation**.\n\n- **Types of Linked Lists:**\n  1. **Singly Linked List** – Each node has **data** and a **pointer** to the next node.\n  2. **Doubly Linked List** – Each node has **data**, a **next pointer**, and a **previous pointer**.\n  3. **Circular Linked List** – The last node points back to the first node.\n\n- **Basic Structure of a Node:**\n  ```java\n  class Node {\n      int data;\n      Node next;\n      Node(int data) {\n          this.data = data;\n          this.next = null;\n      }\n  }\n  ```\n\n- **Advantages of Linked Lists over Arrays:**\n  - **Dynamic Size:** Can grow or shrink as needed.\n  - **Efficient Insertions/Deletions:** No shifting of elements like in arrays.\n  - **Memory Efficient for Large Data Sets:** Does not require pre-allocated memory.\n\n- **Basic Operations in Linked Lists:**\n  - **Insertion** – Add nodes at the beginning, middle, or end.\n  - **Deletion** – Remove a specific node.\n  - **Traversal** – Iterate through the list to access elements.\n\n- **Example: Inserting a Node at the Beginning:**\n  ```java\n  public class LinkedListDemo {\n      static class Node {\n          int data;\n          Node next;\n          Node(int data) { this.data = data; this.next = null; }\n      }\n      \n      public static Node insertAtHead(Node head, int newData) {\n          Node newNode = new Node(newData);\n          newNode.next = head;\n          return newNode;\n      }\n      \n      public static void main(String[] args) {\n          Node head = new Node(10);\n          head = insertAtHead(head, 5);\n          System.out.println(\"Head Node: \" + head.data); // Output: 5\n      }\n  }\n  ```\n\n- **Real-World Applications of Linked Lists:**\n  - **Memory management (Garbage Collection)**.\n  - **Implementation of Stacks and Queues**.\n  - **Undo/Redo functionality in text editors**.\n  - **Dynamic data structures in games and operating systems**.\n\nMastering **Linked Lists** is essential for **data structure optimization, competitive programming, and system design**."
                        },
                        {
                            "id": "mini5",
                            "name": "Reverse a Linked List in Java",
                            "videos": ["https://www.youtube.com/embed/t7YaoQOFXzk"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture explains **how to reverse a Linked List in Java**, covering iterative and recursive methods.\n\n- **What is Linked List Reversal?**\n  - The process of reversing the order of nodes in a linked list so that the last node becomes the head and the head becomes the last node.\n\n- **Approaches to Reverse a Linked List:**\n  1. **Iterative Method** – Using three pointers (`prev`, `current`, `next`).\n  2. **Recursive Method** – Reversing the list by calling the function recursively.\n\n- **Iterative Approach:**\n  ```java\n  class Node {\n      int data;\n      Node next;\n      Node(int data) { this.data = data; this.next = null; }\n  }\n\n  public class ReverseLinkedList {\n      public static Node reverseIterative(Node head) {\n          Node prev = null;\n          Node current = head;\n          while (current != null) {\n              Node next = current.next;\n              current.next = prev;\n              prev = current;\n              current = next;\n          }\n          return prev;\n      }\n  }\n  ```\n\n- **Recursive Approach:**\n  ```java\n  public static Node reverseRecursive(Node head) {\n      if (head == null || head.next == null) return head;\n      Node newHead = reverseRecursive(head.next);\n      head.next.next = head;\n      head.next = null;\n      return newHead;\n  }\n  ```\n\n- **Time Complexity:**\n  - **Iterative Method:** `O(n)`\n  - **Recursive Method:** `O(n)` (but uses additional stack space `O(n)`).\n\n- **Real-World Applications:**\n  - **Reversing history logs (Undo operations)**.\n  - **Reversing playlists in music apps**.\n  - **Backtracking algorithms** that require list traversal in reverse order.\n\nUnderstanding **Linked List Reversal** is essential for mastering **data structures, coding interviews, and system design**."
                        },
                        {
                            "id": "mini6",
                            "name": "Linked List Questions in Java",
                            "videos": ["https://www.youtube.com/embed/cL4gHVuFOvk"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture covers **important Linked List questions in Java**, focusing on problem-solving techniques commonly asked in coding interviews.\n\n- **Topics Covered:**\n  1. **Detect a Cycle in a Linked List** – Using Floyd’s Cycle Detection Algorithm.\n  2. **Find the Middle Node of a Linked List** – Using the slow and fast pointer approach.\n  3. **Merge Two Sorted Linked Lists** – Implementing an efficient merge function.\n  4. **Remove Nth Node from End of List** – Using a two-pointer technique.\n  5. **Check if a Linked List is Palindromic** – Reversing the second half and comparing.\n\n- **Example Code (Detect Cycle in Linked List):**\n  ```java\n  class Node {\n      int data;\n      Node next;\n      Node(int data) { this.data = data; this.next = null; }\n  }\n\n  public class LinkedListCycle {\n      public static boolean hasCycle(Node head) {\n          Node slow = head, fast = head;\n          while (fast != null && fast.next != null) {\n              slow = slow.next;\n              fast = fast.next.next;\n              if (slow == fast) return true;\n          }\n          return false;\n      }\n  }\n  ```\n\n- **Time Complexity Analysis:**\n  - **Cycle Detection:** `O(n)`\n  - **Finding Middle Node:** `O(n)`\n  - **Merging Sorted Lists:** `O(n + m)`\n  - **Removing Nth Node:** `O(n)`\n  - **Checking Palindrome:** `O(n)`\n\n- **Real-World Applications:**\n  - Used in **memory-efficient data storage** (e.g., blockchains, file allocation systems).\n  - Helps in **solving graph traversal problems** (e.g., detecting cycles in networks).\n  - Used in **browser history management** and **undo-redo functionalities**.\n\nUnderstanding these **Linked List problems** is crucial for **competitive programming and software development interviews**."
                        },
                        {
                            "id": "mini7",
                            "name": "Stack in Java",
                            "videos": ["https://www.youtube.com/embed/7m1DMYAbdiY"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture explains **Stacks in Java**, a fundamental data structure used in recursion, expression evaluation, and backtracking.\n\n- **What is a Stack?**\n  - A **LIFO (Last-In, First-Out)** data structure.\n  - Elements are added and removed from the **top**.\n\n- **Stack Operations:**\n  1. **Push (Insert Element)** – Adds an element to the top.\n  2. **Pop (Remove Element)** – Removes the top element.\n  3. **Peek (Top Element Access)** – Returns the top element without removing it.\n  4. **isEmpty (Check if Empty)** – Returns `true` if stack is empty.\n\n- **Implementation in Java (Using Stack Class):**\n  ```java\n  import java.util.Stack;\n\n  public class StackExample {\n      public static void main(String[] args) {\n          Stack<Integer> stack = new Stack<>();\n          stack.push(10);\n          stack.push(20);\n          stack.push(30);\n          System.out.println(\"Top Element: \" + stack.peek()); // Output: 30\n          stack.pop();\n          System.out.println(\"Stack after pop: \" + stack);\n      }\n  }\n  ```\n\n- **Applications of Stack:**\n  - **Function Call Stack (Recursion).**\n  - **Undo/Redo Functionality** (Text Editors, Browsers).\n  - **Expression Evaluation & Conversion** (Infix to Postfix, Parenthesis Matching).\n  - **Backtracking Algorithms** (Maze solving, DFS in Graphs).\n\n- **Time Complexity:**\n  - **Push:** `O(1)`\n  - **Pop:** `O(1)`\n  - **Peek:** `O(1)`\n  - **Search (contains method):** `O(n)`\n\nMastering **Stacks** is essential for **problem-solving and competitive programming**."
                        },
                        {
                            "id": "mini8",
                            "name": "Queue in Java",
                            "videos": ["https://www.youtube.com/embed/va_6RmSrKCg"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture covers **Queue in Java**, an essential data structure for handling sequential processing.\n\n- **What is a Queue?**\n  - A **FIFO (First-In, First-Out)** data structure.\n  - Elements are inserted from the **rear** and removed from the **front**.\n\n- **Types of Queues:**\n  1. **Simple Queue** – Elements follow FIFO.\n  2. **Circular Queue** – The rear connects back to the front.\n  3. **Deque (Double-Ended Queue)** – Insert/remove from both ends.\n  4. **Priority Queue** – Elements processed based on priority.\n\n- **Queue Operations:**\n  1. **Enqueue (Insert Element)** – Adds an element at the rear.\n  2. **Dequeue (Remove Element)** – Removes an element from the front.\n  3. **Front (Peek Element)** – Returns the front element without removing it.\n  4. **isEmpty (Check if Empty)** – Returns `true` if the queue is empty.\n\n- **Implementation in Java (Using Queue Interface - LinkedList):**\n  ```java\n  import java.util.*;\n  \n  public class QueueExample {\n      public static void main(String[] args) {\n          Queue<Integer> queue = new LinkedList<>();\n          queue.add(10);\n          queue.add(20);\n          queue.add(30);\n          System.out.println(\"Front Element: \" + queue.peek()); // Output: 10\n          queue.remove();\n          System.out.println(\"Queue after removal: \" + queue);\n      }\n  }\n  ```\n\n- **Applications of Queue:**\n  - **Task Scheduling** (CPU Scheduling, Printer Queue).\n  - **Breadth-First Search (BFS) Algorithm in Graphs.**\n  - **Handling Requests in Servers & Messaging Queues.**\n  - **Data Buffering (Keyboard Buffers, Disk Scheduling).**\n\n- **Time Complexity:**\n  - **Enqueue:** `O(1)` (LinkedList) / `O(log n)` (PriorityQueue)\n  - **Dequeue:** `O(1)` (LinkedList) / `O(log n)` (PriorityQueue)\n  - **Peek:** `O(1)`\n\nUnderstanding **Queues** is crucial for efficient task processing and problem-solving."
                        },
                        {
                            "id": "mini9",
                            "name": "Tree Data Structure in Java",
                            "videos": ["https://www.youtube.com/embed/-DzowlcaUmE"],
                            "pdfs": ["https://docs.google.com/document/d/1d4cDG1bAVjvvKLjD9ZPQdJEGsQyGn_UIqCuluVmx5_0/preview"],
                            "description": "This lecture introduces **Tree Data Structures in Java**, an essential hierarchical structure used in various applications.\n\n- **What is a Tree?**\n  - A **non-linear data structure** with a hierarchical relationship.\n  - Consists of **nodes** connected by **edges**.\n  - The **root node** is the starting point.\n\n- **Types of Trees:**\n  1. **Binary Tree** – Each node has at most **two children**.\n  2. **Binary Search Tree (BST)** – Left child < Parent < Right child.\n  3. **AVL Tree** – A self-balancing BST.\n  4. **B-Trees & B+ Trees** – Used in databases for indexing.\n  5. **Trie (Prefix Tree)** – Used in searching and autocomplete.\n\n- **Tree Terminologies:**\n  - **Root Node** – The topmost node.\n  - **Parent & Child Nodes** – Nodes connected directly.\n  - **Leaf Node** – Nodes without children.\n  - **Height of Tree** – Longest path from root to leaf.\n\n- **Binary Tree Implementation in Java:**\n  ```java\n  class Node {\n      int data;\n      Node left, right;\n      public Node(int item) {\n          data = item;\n          left = right = null;\n      }\n  }\n\n  class BinaryTree {\n      Node root;\n      void inorder(Node node) {\n          if (node == null) return;\n          inorder(node.left);\n          System.out.print(node.data + \" \");\n          inorder(node.right);\n      }\n      public static void main(String[] args) {\n          BinaryTree tree = new BinaryTree();\n          tree.root = new Node(1);\n          tree.root.left = new Node(2);\n          tree.root.right = new Node(3);\n          System.out.println(\"Inorder Traversal:\");\n          tree.inorder(tree.root);\n      }\n  }\n  ```\n\n- **Tree Traversal Techniques:**\n  1. **Inorder (Left → Root → Right)** – Used in BSTs.\n  2. **Preorder (Root → Left → Right)** – Used for tree cloning.\n  3. **Postorder (Left → Right → Root)** – Used in expression trees.\n  4. **Level Order (BFS)** – Used in shortest path algorithms.\n\n- **Applications of Trees:**\n  - **Hierarchical Data Representation** (File Systems, XML/HTML Parsing).\n  - **Database Indexing (B-Trees, B+ Trees).**\n  - **Artificial Intelligence (Decision Trees).**\n  - **Network Routing Algorithms (Spanning Trees).**\n\n- **Time Complexity:**\n  - **Insertion, Deletion, Searching in BST:** `O(log n)` (Balanced) / `O(n)` (Unbalanced)\n  - **Tree Traversals:** `O(n)`\n\nUnderstanding **Trees** is essential for advanced data structures and algorithms."
                        },
                        {
                            "id": "mini10",
                            "name": "Binary Search Tree (BST) in Java",
                            "videos": ["https://www.youtube.com/embed/qAeitQWjNNg"],
                            "pdfs": ["https://docs.google.com/document/d/1mZlCgJH72r7aA8LXpDwC_NJf9xXyQhCrF3OaE6H9_5g/preview"],
                            "description": "This lecture introduces **Binary Search Trees (BST)** in Java, an essential data structure for fast searching, insertion, and deletion.\n\n- **What is a BST?**\n  - A special type of **Binary Tree**.\n  - **Left subtree** contains values smaller than the root.\n  - **Right subtree** contains values greater than the root.\n  - No duplicate nodes allowed.\n\n- **BST Properties:**\n  1. **Efficient Search:** `O(log n)` time complexity in a balanced BST.\n  2. **Ordered Structure:** Inorder traversal results in a sorted sequence.\n  3. **Dynamic Data Structure:** Can dynamically grow and shrink.\n\n- **BST Implementation in Java:**\n  ```java\n  class Node {\n      int data;\n      Node left, right;\n      public Node(int item) {\n          data = item;\n          left = right = null;\n      }\n  }\n\n  class BST {\n      Node root;\n      BST() { root = null; }\n\n      void insert(int key) {\n          root = insertRec(root, key);\n      }\n\n      Node insertRec(Node root, int key) {\n          if (root == null) {\n              root = new Node(key);\n              return root;\n          }\n          if (key < root.data)\n              root.left = insertRec(root.left, key);\n          else if (key > root.data)\n              root.right = insertRec(root.right, key);\n          return root;\n      }\n\n      void inorder() {\n          inorderRec(root);\n      }\n\n      void inorderRec(Node root) {\n          if (root != null) {\n              inorderRec(root.left);\n              System.out.print(root.data + \" \");\n              inorderRec(root.right);\n          }\n      }\n\n      public static void main(String[] args) {\n          BST tree = new BST();\n          tree.insert(50);\n          tree.insert(30);\n          tree.insert(70);\n          tree.insert(20);\n          tree.insert(40);\n          tree.insert(60);\n          tree.insert(80);\n          System.out.println(\"Inorder traversal of BST:\");\n          tree.inorder();\n      }\n  }\n  ```\n\n- **BST Operations:**\n  1. **Insertion** - Insert new values maintaining the BST property.\n  2. **Searching** - Efficient `O(log n)` search if BST is balanced.\n  3. **Deletion** - Delete a node with three cases:\n     - Node has no children (Leaf Node).\n     - Node has one child (Replace with child).\n     - Node has two children (Replace with **inorder successor**).\n\n- **Tree Traversal in BST:**\n  - **Inorder (Left → Root → Right):** Gives sorted order.\n  - **Preorder (Root → Left → Right):** Used for cloning trees.\n  - **Postorder (Left → Right → Root):** Used in tree deletion.\n\n- **Time Complexity:**\n  - **Best/Average Case (Balanced BST):** `O(log n)`.\n  - **Worst Case (Unbalanced BST, like a linked list):** `O(n)`.\n\n- **Applications of BST:**\n  - **Efficient searching and sorting.**\n  - **Database indexing.**\n  - **Auto-complete suggestions.**\n  - **Implementation of maps and sets.**"
                        },
                        {
                            "id": "mini11",
                            "name": "HashSet in Java",
                            "videos": ["https://www.youtube.com/embed/eJiGN1h8XzM"],
                            "pdfs": ["https://docs.google.com/document/d/1xYhNqVZ-3xU9qW5MbT2GJGzXZa3FJ7kJ8PoA8M8LJxE/preview"],
                            "description": "This lecture introduces **HashSet** in Java, a key implementation of the **Set interface** in the Java Collections Framework (JCF).\n\n- **What is a HashSet?**\n  - A **unordered collection** that contains **unique elements only**.\n  - **Uses HashMap internally** for storing values.\n  - **Does not allow duplicate elements**.\n  - **Fast operations** (O(1) average time for add, remove, and contains).\n\n- **Features of HashSet:**\n  1. **No Duplicates:** Stores unique values.\n  2. **Unordered Collection:** No guaranteed order of elements.\n  3. **Allows Null Values:** Can store at most one `null` value.\n  4. **Thread Unsafe:** Needs manual synchronization if used in multi-threaded environments.\n  5. **Uses Hashing:** Provides `O(1)` average time complexity for operations.\n\n- **Basic Operations in HashSet:**\n  ```java\n  import java.util.*;\n\n  public class HashSetExample {\n      public static void main(String[] args) {\n          // Creating a HashSet\n          HashSet<String> set = new HashSet<>();\n          \n          // Adding elements\n          set.add(\"Apple\");\n          set.add(\"Banana\");\n          set.add(\"Cherry\");\n          set.add(\"Apple\"); // Duplicate, won't be added\n          \n          // Printing the HashSet\n          System.out.println(\"HashSet Elements: \" + set);\n          \n          // Checking if an element exists\n          System.out.println(\"Contains Banana? \" + set.contains(\"Banana\"));\n          \n          // Removing an element\n          set.remove(\"Cherry\");\n          \n          // Iterating over the HashSet\n          for (String fruit : set) {\n              System.out.println(fruit);\n          }\n      }\n  }\n  ```\n\n- **Common HashSet Methods:**\n  - `add(element)`: Adds an element to the set.\n  - `remove(element)`: Removes an element if present.\n  - `contains(element)`: Checks if an element exists.\n  - `size()`: Returns the number of elements.\n  - `isEmpty()`: Checks if the set is empty.\n  - `clear()`: Removes all elements.\n\n- **Performance & Time Complexity:**\n  - **Insertion:** `O(1)` (on average, depends on hash collisions).\n  - **Deletion:** `O(1)` (on average, but can degrade to `O(n)` in worst cases).\n  - **Search (contains):** `O(1)` (on average, `O(n)` in worst case if many hash collisions occur).\n\n- **Applications of HashSet:**\n  - **Removing Duplicates from Lists.**\n  - **Faster Membership Testing (`contains()`).**\n  - **Storing Unique Elements for Quick Lookups.**\n  - **Used in Caching, Cryptography, and Unique Object Storage.**"
                        },
                        {
                            "id": "mini12",
                            "name": "HashSet Implementation in Java",
                            "videos": ["https://www.youtube.com/embed/KDZ_IXvpMG4"],
                            "pdfs": ["https://docs.google.com/document/d/1A7GJGzX-9Bq8qK5MbT2HJZzXa4FJ7kJ8PoA9M8LJxY/preview"],
                            "description": "This lecture explains how **HashSet is implemented internally** in Java, covering its **data structure**, **working mechanism**, and **custom implementation**.\n\n### **1. Internal Working of HashSet**\n- **Uses HashMap internally** (`HashSet<E> internally uses HashMap<E, Object>`).\n- **Stores elements as HashMap keys** with a constant dummy value.\n- **Handles collisions using Linked List or Tree (after Java 8)**.\n\n### **2. Custom HashSet Implementation**\n**Steps to Implement a HashSet from Scratch:**\n1. Use an **Array of Linked Lists** (Separate Chaining) or **Open Addressing**.\n2. Implement `add()`, `remove()`, and `contains()` methods.\n3. Handle **hash collisions** using **Linked Lists**.\n4. Implement **dynamic resizing** for better efficiency.\n\n### **3. Code: Custom HashSet Implementation**\n```java\nimport java.util.LinkedList;\n\nclass MyHashSet {\n    private static final int SIZE = 1000;\n    private LinkedList<Integer>[] buckets;\n\n    public MyHashSet() {\n        buckets = new LinkedList[SIZE];\n    }\n    \n    private int hash(int key) {\n        return key % SIZE;\n    }\n    \n    public void add(int key) {\n        int index = hash(key);\n        if (buckets[index] == null) {\n            buckets[index] = new LinkedList<>();\n        }\n        if (!buckets[index].contains(key)) {\n            buckets[index].add(key);\n        }\n    }\n    \n    public void remove(int key) {\n        int index = hash(key);\n        if (buckets[index] != null) {\n            buckets[index].remove((Integer) key);\n        }\n    }\n    \n    public boolean contains(int key) {\n        int index = hash(key);\n        return buckets[index] != null && buckets[index].contains(key);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        MyHashSet set = new MyHashSet();\n        set.add(5);\n        set.add(15);\n        System.out.println(set.contains(5)); // true\n        set.remove(5);\n        System.out.println(set.contains(5)); // false\n    }\n}\n```\n\n### **4. Key Takeaways**\n- Uses **hash function (`key % SIZE`)** for indexing.\n- Uses **Linked List** to handle **collisions**.\n- **Time Complexity:**\n  - `add()`: **O(1) (average), O(n) (worst case - collisions)**\n  - `remove()`: **O(1) (average), O(n) (worst case - collisions)**\n  - `contains()`: **O(1) (average), O(n) (worst case - collisions)**\n- **Can be optimized using Tree-based approach (Java 8+).**\n\n### **5. Applications of Custom HashSet**\n- **Efficient data storage for unique elements.**\n- **Faster lookup compared to ArrayList.**\n- **Used in database indexing, caching, and hashing-based searches.**"
                        },
                        {
                            "id": "mini13",
                            "name": "HashMap in Java",
                            "videos": ["https://www.youtube.com/embed/WeF3_nk-UqY"],
                            "pdfs": ["https://docs.google.com/document/d/1XZKDwFJ7vPq2LJ4BnJH8LX8M9KXqRzY8-ABCD45/preview"],
                            "description": "This lecture covers **HashMap in Java**, its **internal implementation**, **working**, and **how to use it efficiently**.\n\n### **1. What is a HashMap?**\n- A **key-value pair data structure** in Java.\n- Uses **hashing** to store and retrieve data in **O(1) average time**.\n- Allows **one null key and multiple null values**.\n- Part of the **Java Collection Framework** (`java.util.HashMap`).\n\n### **2. Internal Working of HashMap**\n- Uses an **array of Linked Lists (before Java 8)** or **Tree (Java 8+)** for storing entries.\n- Each entry is stored as a **Node<K, V> (key-value pair).**\n- Hashing determines **bucket index** using `hashCode()`.\n- Handles **collisions** using **Separate Chaining (Linked List)** or **Tree (Java 8+ when nodes > 8)**.\n\n### **3. Basic HashMap Operations**\n```java\nimport java.util.HashMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        HashMap<String, Integer> map = new HashMap<>();\n        \n        // Adding elements\n        map.put(\"Alice\", 25);\n        map.put(\"Bob\", 30);\n        map.put(\"Charlie\", 22);\n        \n        // Accessing values\n        System.out.println(\"Age of Bob: \" + map.get(\"Bob\")); // 30\n        \n        // Checking key presence\n        System.out.println(\"Contains Alice? \" + map.containsKey(\"Alice\")); // true\n        \n        // Removing an entry\n        map.remove(\"Charlie\");\n        \n        // Iterating through HashMap\n        for (String key : map.keySet()) {\n            System.out.println(key + \" -> \" + map.get(key));\n        }\n    }\n}\n```\n\n### **4. Time Complexity of HashMap Operations**\n| Operation  | Average Case | Worst Case (Collision) |\n|------------|--------------|------------------------|\n| `put()`   | **O(1)**     | **O(n)**               |\n| `get()`   | **O(1)**     | **O(n)**               |\n| `remove()`| **O(1)**     | **O(n)**               |\n| `containsKey()` | **O(1)** | **O(n)**               |\n\n### **5. Key Takeaways**\n- **Best for fast key-value lookups.**\n- **Handles collisions using Linked Lists (Java 7) and Trees (Java 8+).**\n- **Resizes dynamically when load factor > 0.75**.\n- **Used in Caching, LRU Cache, Graphs (Adjacency List), and more.**\n\n### **6. Applications of HashMap**\n- **Fast data retrieval** (e.g., Dictionary, Caching).\n- **Storing frequency counts** (e.g., Word Count, Anagram Checker).\n- **Used in Graphs (Adjacency List Representation).**"
                        },  
                        {
                            "id": "mini14",
                            "name": "Hashing in Java",
                            "videos": ["https://www.youtube.com/embed/rTRcntABSZ4"],
                            "pdfs": ["https://docs.google.com/document/d/1YZX23J4aKX9LWJ5BvH8RT9MZ8XQKPL89-ABCD67/preview"],
                            "description": "This lecture covers **Hashing in Java**, including **hash functions, collision handling, and real-world applications**.\n\n### **1. What is Hashing?**\n- A technique to **convert input data into a fixed-size value (hash code)**.\n- Used in **fast data retrieval**, **password storage**, **data structures (HashMap, HashSet)**.\n- **Key idea:** Store elements in **buckets using hash codes**.\n\n### **2. Types of Hashing**\n- **Direct Hashing:** Key is used as the index directly.\n- **Modular Hashing (`key % tableSize`)**: Common technique for distributing keys.\n- **Multiplication Hashing:** Uses fractions of a number to determine index.\n\n### **3. Collision Handling Techniques**\n| Technique            | Description |\n|----------------------|-------------|\n| **Chaining**        | Uses a **Linked List** to store multiple values in a single bucket. |\n| **Open Addressing** | Stores data in the next available empty slot when a collision occurs. |\n| **Double Hashing**  | Uses a second hash function to resolve collisions. |\n\n### **4. Basic Hashing Code Example in Java**\n```java\nimport java.util.HashMap;\n\npublic class HashingExample {\n    public static void main(String[] args) {\n        HashMap<Integer, String> hashMap = new HashMap<>();\n        \n        // Inserting elements\n        hashMap.put(101, \"Alice\");\n        hashMap.put(102, \"Bob\");\n        hashMap.put(103, \"Charlie\");\n        \n        // Retrieving values\n        System.out.println(\"Value for key 102: \" + hashMap.get(102));\n        \n        // Checking for existence\n        System.out.println(\"Contains key 101? \" + hashMap.containsKey(101));\n    }\n}\n```\n\n### **5. Applications of Hashing**\n- **Fast lookup in databases (Indexes, Hash Tables).**\n- **Cryptography (SHA, MD5 for password hashing).**\n- **Data structures (HashMap, HashSet, LRU Cache).**\n- **Load Balancing, Caching, and more.**\n\n### **6. Time Complexity**\n| Operation   | Average Case | Worst Case (Collision) |\n|------------|--------------|------------------------|\n| Insert     | **O(1)**     | **O(n)**               |\n| Search     | **O(1)**     | **O(n)**               |\n| Delete     | **O(1)**     | **O(n)**               |\n\n### **7. Key Takeaways**\n- **Hashing enables fast retrieval and storage of data.**\n- **Collision handling is crucial for efficient hashing.**\n- **Used in real-world applications like password hashing and databases.**"
                        },
                        {
                            "id": "mini15",
                            "name": "Trie Data Structure",
                            "videos": ["https://www.youtube.com/embed/m9zawMC6QAI"],
                            "pdfs": ["https://docs.google.com/document/d/1A2B3C4D5E6F7G8H9IJKLMNOPQRSTUV/preview"],
                            "description": "This lecture covers **Trie Data Structure**, explaining its **concept, implementation, and applications**.\n\n### **1. What is a Trie?**\n- **Trie (Prefix Tree)** is a tree-based data structure used for **efficient string searching**.\n- Stores words such that **each node represents a single character**.\n- **Key idea:** Common prefixes are stored together to optimize search.\n\n### **2. Operations in Trie**\n| Operation   | Description |\n|------------|-------------|\n| **Insert** | Adds a word character-by-character into the Trie. |\n| **Search** | Checks if a word exists in the Trie. |\n| **Delete** | Removes a word from the Trie (if present). |\n| **Prefix Search** | Finds words starting with a given prefix. |\n\n### **3. Basic Trie Node Structure in Java**\n```java\nclass TrieNode {\n    TrieNode[] children = new TrieNode[26];\n    boolean isEndOfWord;\n    \n    TrieNode() {\n        isEndOfWord = false;\n        for (int i = 0; i < 26; i++) {\n            children[i] = null;\n        }\n    }\n}\n```\n\n### **4. Trie Insertion & Search in Java**\n```java\nclass Trie {\n    private TrieNode root;\n    \n    public Trie() {\n        root = new TrieNode();\n    }\n    \n    // Insert a word into the Trie\n    public void insert(String word) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            int index = c - 'a';\n            if (node.children[index] == null) {\n                node.children[index] = new TrieNode();\n            }\n            node = node.children[index];\n        }\n        node.isEndOfWord = true;\n    }\n    \n    // Search for a word in the Trie\n    public boolean search(String word) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            int index = c - 'a';\n            if (node.children[index] == null) return false;\n            node = node.children[index];\n        }\n        return node.isEndOfWord;\n    }\n}\n```\n\n### **5. Applications of Trie**\n- **Autocomplete (Google Search, Mobile Keyboards).**\n- **Spell Checking.**\n- **IP Routing.**\n- **Dictionary & Prefix-based Search.**\n\n### **6. Time Complexity**\n| Operation   | Average Case | Worst Case |\n|------------|--------------|-------------|\n| Insert     | **O(n)**     | **O(n)**     |\n| Search     | **O(n)**     | **O(n)**     |\n| Delete     | **O(n)**     | **O(n)**     |\n\n### **7. Key Takeaways**\n- **Trie is a tree-based structure that optimizes string operations.**\n- **Efficient for prefix searching & autocomplete.**\n- **Used in real-world applications like search engines and text processing.**"
                        },
                        {
                            "id": "mini16",
                            "name": "Graph Data Structure",
                            "videos": ["https://www.youtube.com/embed/59fUtYYz7ZU"],
                            "pdfs": ["https://docs.google.com/document/d/1X2Y3Z4A5B6C7D8E9JKLMNOPQRSTUV/preview"],
                            "description": "This lecture covers **Graph Data Structure**, explaining its **types, representation, and traversal techniques**.\n\n### **1. What is a Graph?**\n- A **graph** is a collection of **nodes (vertices) and edges**.\n- Used to represent **networks, social connections, roads, etc.**\n\n### **2. Types of Graphs**\n| Type | Description |\n|------|-------------|\n| **Directed Graph** | Edges have a direction (A → B). |\n| **Undirected Graph** | Edges have no direction (A — B). |\n| **Weighted Graph** | Edges have weights (cost, distance, etc.). |\n| **Unweighted Graph** | Edges have no weights. |\n| **Cyclic Graph** | Graph contains at least one cycle. |\n| **Acyclic Graph** | Graph has no cycles. |\n\n### **3. Graph Representation**\n| Method | Description | Space Complexity |\n|--------|-------------|------------------|\n| **Adjacency Matrix** | 2D array storing edge presence (1/0). | O(V²) |\n| **Adjacency List** | Stores a list of neighbors for each vertex. | O(V + E) |\n\n### **4. Graph Implementation in Java (Adjacency List)**\n```java\nimport java.util.*;\n\nclass Graph {\n    private Map<Integer, List<Integer>> adjList;\n    \n    Graph() {\n        adjList = new HashMap<>();\n    }\n    \n    // Add an edge to the graph\n    void addEdge(int u, int v) {\n        adjList.putIfAbsent(u, new ArrayList<>());\n        adjList.putIfAbsent(v, new ArrayList<>());\n        adjList.get(u).add(v);\n        adjList.get(v).add(u); // Remove this for a directed graph\n    }\n    \n    // Print the adjacency list\n    void printGraph() {\n        for (int node : adjList.keySet()) {\n            System.out.println(node + \" -> \" + adjList.get(node));\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Graph g = new Graph();\n        g.addEdge(1, 2);\n        g.addEdge(1, 3);\n        g.addEdge(2, 4);\n        g.addEdge(3, 4);\n        g.printGraph();\n    }\n}\n```\n\n### **5. Graph Traversal Algorithms**\n#### **Breadth-First Search (BFS) (Queue-based)**\n- **Explores neighbors level by level.**\n- **Uses Queue (FIFO) for traversal.**\n```java\nvoid bfs(int start) {\n    Queue<Integer> queue = new LinkedList<>();\n    Set<Integer> visited = new HashSet<>();\n    queue.add(start);\n    visited.add(start);\n    \n    while (!queue.isEmpty()) {\n        int node = queue.poll();\n        System.out.print(node + \" \");\n        \n        for (int neighbor : adjList.get(node)) {\n            if (!visited.contains(neighbor)) {\n                queue.add(neighbor);\n                visited.add(neighbor);\n            }\n        }\n    }\n}\n```\n#### **Depth-First Search (DFS) (Stack/Recursion-based)**\n- **Explores depth before breadth.**\n- **Uses Stack (LIFO) or Recursion for traversal.**\n```java\nvoid dfs(int node, Set<Integer> visited) {\n    if (visited.contains(node)) return;\n    visited.add(node);\n    System.out.print(node + \" \");\n    \n    for (int neighbor : adjList.get(node)) {\n        dfs(neighbor, visited);\n    }\n}\n```\n\n### **6. Applications of Graphs**\n- **Social Networks (Facebook, LinkedIn).**\n- **Google Maps (Shortest Path Algorithms).**\n- **Recommendation Systems (YouTube, Netflix).**\n- **Network Routing (Dijkstra, Floyd-Warshall).**\n\n### **7. Time Complexity**\n| Operation   | Adjacency Matrix | Adjacency List |\n|------------|-----------------|-----------------|\n| Add Edge   | **O(1)**        | **O(1)**        |\n| Remove Edge| **O(1)**        | **O(V)**        |\n| BFS/DFS    | **O(V²)**       | **O(V + E)**    |\n\n### **8. Key Takeaways**\n✔ **Graphs are powerful for modeling real-world problems.**\n✔ **Adjacency List is preferred for large graphs (less memory usage).**\n✔ **BFS and DFS are fundamental traversal techniques.**\n✔ **Used in AI, ML, Computer Networks, and Game Development.**"
                        }                                                                                                                                                                                                                                                                                                                                                                                                    
                    ]
                }                    
            ]
        },
        {
            "id": "course2",
            "name": "C Programming",
            "chapters": [
                {
                    "id": "chapter1",
                    "name": "Introduction",
                    "miniChapters": [
                        {
                            "id": "mini1",
                            "name": "Introduction",
                            "videos": ["https://www.youtube.com/embed/irqbmMNs2Bo?start=0&end=87"],
                            "pdfs": ["https://drive.google.com/file/d/1vcwggs0_rWh89WC1Fg3pZ6hUYLWqU9Eg/preview"],
                            "description": "This section introduces C programming, its history, and fundamental concepts."
                        }
                    ]
                },
                {
                    "id": "chapter2",
                    "name": "Installation & Setup",
                    "miniChapters": [
                        {
                            "id": "mini2",
                            "name": "VS Code Installation",
                            "videos": ["https://www.youtube.com/embed/irqbmMNs2Bo?start=87&end=271"],
                            "pdfs": ["https://drive.google.com/file/d/1BG3ybTLFVKFjTyYY55aCbxNqE92c70Gx/preview"],
                            "description": "Guide to installing VS Code and setting up for C programming."
                        },
                        {
                            "id": "mini3",
                            "name": "Compiler + Setup",
                            "videos": ["https://www.youtube.com/embed/irqbmMNs2Bo?start=271&end=612"],
                            "pdfs": ["https://drive.google.com/file/d/1sjOPF0-hRg16ZthsCAkqA3f78wkwzVUa/preview"],
                            "description": "Setting up a C compiler and configuring the development environment."
                        }
                    ]
                },
                {
                    "id": "chapter3",
                    "name": "Fundamentals of C",
                    "miniChapters": [
                        {
                            "id": "mini4",
                            "name": "Variables, Data Types & I/O",
                            "videos": ["https://www.youtube.com/embed/irqbmMNs2Bo?start=612&end=3114"],
                            "pdfs": ["https://drive.google.com/file/d/1sjOPF0-hRg16ZthsCAkqA3f78wkwzVUa/preview"],
                            "description": "Understanding variables, data types, and input/output operations in C."
                        },
                        {
                            "id": "mini5",
                            "name": "Instructions & Operators",
                            "videos": ["https://www.youtube.com/embed/irqbmMNs2Bo?start=3114&end=7275"],
                            "pdfs": ["https://drive.google.com/file/d/1jsMv-VAC6K4wbl9FOKQUxAMLwAs-ArM-/preview"],
                            "description": "Exploring C instructions, arithmetic, logical, and bitwise operators."
                        }
                    ]
                },
                {
                    "id": "chapter4",
                    "name": "Control Flow",
                    "miniChapters": [
                        {
                            "id": "mini6",
                            "name": "Conditional Statements",
                            "videos": ["https://www.youtube.com/embed/irqbmMNs2Bo?start=7275&end=9936"],
                            "pdfs": ["https://drive.google.com/file/d/1NROR6CGkxsfsWu48OR-gWyPrdTiIG6T0/preview"],
                            "description": "Understanding if-else statements, switch-case, and logical conditions."
                        },
                        {
                            "id": "mini7",
                            "name": "Loop Control Statements",
                            "videos": ["https://www.youtube.com/embed/irqbmMNs2Bo?start=9936&end=13894"],
                            "pdfs": ["https://drive.google.com/file/d/1cSV_Ykj25EVqfFO65FeCC8kQ7-NhpFVR/preview"],
                            "description": "Working with loops: for, while, and do-while."
                        }
                    ]
                },
                {
                    "id": "chapter5",
                    "name": "Advanced Concepts",
                    "miniChapters": [
                        {
                            "id": "mini8",
                            "name": "Functions & Recursion",
                            "videos": ["https://www.youtube.com/embed/irqbmMNs2Bo?start=13894&end=19290"],
                            "pdfs": ["https://drive.google.com/file/d/1I-7ygqAqpWO90GyBDsDHaMtE33HJuBTt/preview"],
                            "description": "Deep dive into functions, recursion, and modular programming."
                        },
                        {
                            "id": "mini9",
                            "name": "Pointers",
                            "videos": ["https://www.youtube.com/embed/irqbmMNs2Bo?start=19290&end=22730"],
                            "pdfs": ["https://drive.google.com/file/d/1NzsUNa8Vcr5wVejluBHWGCYn3jRzo_0s/preview"],
                            "description": "Understanding pointers, memory addresses, and dynamic memory allocation."
                        }
                    ]
                },
                {
                    "id": "chapter6",
                    "name": "Data Structures",
                    "miniChapters": [
                        {
                            "id": "mini10",
                            "name": "Arrays",
                            "videos": ["https://www.youtube.com/embed/irqbmMNs2Bo?start=22730&end=26549"],
                            "pdfs": ["https://drive.google.com/file/d/19iWF36BXQnsV_2xgO6n7cfn7j9kJxbXr/preview"],
                            "description": "Working with arrays: declaration, initialization, and operations."
                        },
                        {
                            "id": "mini11",
                            "name": "Strings",
                            "videos": ["https://www.youtube.com/embed/irqbmMNs2Bo?start=26549&end=30380"],
                            "pdfs": ["https://drive.google.com/file/d/1ts6NSAoLOl5sT3wfkTOpbdISwFQIAb33/preview"],
                            "description": "String handling functions and operations in C."
                        },
                        {
                            "id": "mini12",
                            "name": "Structures",
                            "videos": ["https://www.youtube.com/embed/irqbmMNs2Bo?start=30380&end=33735"],
                            "pdfs": [],
                            "description": "Understanding structures and their importance in C programming."
                        }
                    ]
                },
                {
                    "id": "chapter7",
                    "name": "File Handling & Memory Management",
                    "miniChapters": [
                        {
                            "id": "mini13",
                            "name": "File I/O",
                            "videos": ["https://www.youtube.com/embed/irqbmMNs2Bo?start=33735&end=36300"],
                            "pdfs": [],
                            "description": "Reading, writing, and manipulating files in C."
                        },
                        {
                            "id": "mini14",
                            "name": "Dynamic Memory Allocation",
                            "videos": ["https://www.youtube.com/embed/irqbmMNs2Bo?start=36300"],
                            "pdfs": [],
                            "description": "Allocating and freeing memory dynamically using malloc, calloc, and free."
                        }
                    ]
                }
            ]
        },
        {
            "id": "course2",
            "name": "Linux",
            "chapters": [
                {
                    "id": "chapter1",
                    "name": "Online class",
                            "miniChapters": [
                                {
                                    "id": "mini1",
                                    "name": "1",
                                    "videos": ["https://drive.google.com/file/d/1kHiJh6tTT82yKCXBAeqtJXKH3hoYDFqO/preview"],
                                    "pdfs": ["https://drive.google.com/file/d/1vcwggs0_rWh89WC1Fg3pZ6hUYLWqU9Eg/preview"],
                                    "description": "This section introduces C programming, its history, and fundamental concepts."
                                },
                                {
                                    "id": "mini2",
                                    "name": "2",
                                    "videos": [
                                        "https://drive.google.com/file/d/1sioocSOxwkhwHE7Rd6S6djYtwsz8vwG-/preview"
                                    ],
                                    "pdfs": [
                                        "https://drive.google.com/file/d/1vcwggs0_rWh89WC1Fg3pZ6hUYLWqU9Eg/preview"
                                    ],
                                    "description": "This section introduces C programming, its history, and fundamental concepts."
                                },                                
                                {
                                    "id": "mini2",
                                    "name": "3",
                                    "videos": [
                                        "https://drive.google.com/file/d/1P-VTzFcMEdbVcQ0FasZTFBbquzmOT4Yy/preview"
                                    ],
                                    "pdfs": [
                                        "https://drive.google.com/file/d/1vcwggs0_rWh89WC1Fg3pZ6hUYLWqU9Eg/preview"
                                    ],
                                    "description": "This section introduces C programming, its history, and fundamental concepts."
                                },
                                {
                                    "id": "mini2",
                                    "name": "4",
                                    "videos": [
                                        "https://drive.google.com/file/d/1lBbZl-n_rcdxJ6bFT-Z6StP0LkvOyJzP/preview"
                                    ],
                                    "pdfs": [
                                        "https://drive.google.com/file/d/1vcwggs0_rWh89WC1Fg3pZ6hUYLWqU9Eg/preview"
                                    ],
                                    "description": "This section introduces C programming, its history, and fundamental concepts."
                                },
                                {
                                    "id": "mini2",
                                    "name": "5",
                                    "videos": [
                                        "https://drive.google.com/file/d/1vO1k1YnfUPpFbMVM0IYkNNwyzkZuwmXK/preview"
                                    ],
                                    "pdfs": [
                                        "https://drive.google.com/file/d/1vcwggs0_rWh89WC1Fg3pZ6hUYLWqU9Eg/preview"
                                    ],
                                    "description": "This section introduces C programming, its history, and fundamental concepts."
                                },
                                {
                                    "id": "mini2",
                                    "name": "6",
                                    "videos": [
                                        "https://drive.google.com/file/d/1gfF9TnVBlKjUkI37-aamMZiY5-CU3p4E/preview"
                                    ],
                                    "pdfs": [
                                        "https://drive.google.com/file/d/1vcwggs0_rWh89WC1Fg3pZ6hUYLWqU9Eg/preview"
                                    ],
                                    "description": "This section introduces C programming, its history, and fundamental concepts."
                                },
                                {
                                    "id": "mini2",
                                    "name": "7",
                                    "videos": [
                                        "https://drive.google.com/file/d/1fmFe6hOSm5hD7OXodxY6AASnh_PpqYx4/preview"
                                    ],
                                    "pdfs": [
                                        "https://drive.google.com/file/d/1vcwggs0_rWh89WC1Fg3pZ6hUYLWqU9Eg/preview"
                                    ],
                                    "description": "This section introduces C programming, its history, and fundamental concepts."
                                },
                                {
                                    "id": "mini2",
                                    "name": "8",
                                    "videos": [
                                        "https://drive.google.com/file/d/1I1ZeiFPfi9mu_JLaTtBmC2BS1mOeFkbT/preview"
                                    ],
                                    "pdfs": [
                                        "https://drive.google.com/file/d/1vcwggs0_rWh89WC1Fg3pZ6hUYLWqU9Eg/preview"
                                    ],
                                    "description": "This section introduces C programming, its history, and fundamental concepts."
                                },
                                {
                                    "id": "mini2",
                                    "name": "9",
                                    "videos": [
                                        "https://drive.google.com/file/d/17I4V5F_BDPJ_pStCXqLpuQs8VDF1eIbG/preview"
                                    ],
                                    "pdfs": [
                                        "https://drive.google.com/file/d/1vcwggs0_rWh89WC1Fg3pZ6hUYLWqU9Eg/preview"
                                    ],
                                    "description": "This section introduces C programming, its history, and fundamental concepts."
                                }                                                                                                                                                                                             
                            ]
                        
                }
            ]
        }        
    ]
}
